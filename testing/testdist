#! /usr/bin/python

import os, sys, re, time, subprocess, shlex, stat, glob

help_pat = re.compile(r'--?h(elp)?')
my_folder = os.path.dirname(os.path.normpath(os.path.realpath(__file__)))
home_folder = os.path.expanduser('~')
dist_pat = re.compile(r'^\d\d\d\.zip$')

def find_all_tests():
    tests = []
    for path, dirs, files in os.walk(my_folder):
        for f in files:
            if f.endswith('.json'):
                tests.append(os.path.join(path, f))
    #print('all tests = %s' % tests)
    return tests

def find_all_zips():
    all = [x[:-4] for x in os.listdir(home_folder) if dist_pat.match(x)]
    print ('dist zips = %s' % ', '.join(all))
    return all

def is_binary(fpath):
    if os.path.isfile(fpath):
        x = os.stat(fpath)
        if x.st_mode & stat.S_IXUSR:
            return True
    return False

def dist_has_binaries(zip):
    build_dir = os.path.join(home_folder, zip, 'code', 'build')
    has_them = is_binary('%s/logappend' % build_dir) and is_binary('%s/logread' % build_dir)
    #print('has binaries = %s' % has_them)
    return has_them

def get_unzip_date(zip):
    tracking_file = os.path.join(home_folder, zip, 'unzipped')
    if os.path.isfile(tracking_file):
        return os.stat(tracking_file).st_mtime
    return 0

def get_zip_date(zip):
    zip_path = os.path.join(home_folder, zip + '.zip')
    if (os.path.isfile(zip_path)):
        return os.stat(zip_path).st_mtime
    return 0

def get_binaries_date(zip):
    binary = '%s/%s/code/build/logappend' % (home_folder, zip)
    print('checking date of %s' % binary)
    if os.path.isfile(binary):
        lastmod = os.stat(binary).st_mtime
        #print('lastmod for binaries = %s' % lastmod)
        return lastmod
    return 0

def unzip(zip):
    os.chdir(home_folder)
    unzip_date = get_unzip_date(zip)
    zip_date = get_zip_date(zip)
    #print('zip_date = %s' % zip_date)
    unzipped_folder = os.path.join(home_folder, zip)
    if zip_date > unzip_date:
        #print('Unzipping %s' % zip)
        cmd = 'unzip %s.zip' % zip
        print(cmd)
        os.system(cmd)
        # Touch a file so we can compare lastmod of zip and folder
        open('%s/unzipped' % zip, 'w').close()
    if (not dist_has_binaries(zip)) or get_binaries_date(zip) < zip_date:
        os.system('make -C %s/code/build' % unzipped_folder)
        if not dist_has_binaries(zip):
            print("ERROR: %s build is broken." % zip)
            return ''
    return unzipped_folder
        
def find_matching_tests(name, all_tests):
    matches = []
    if '*' or '?' in name:
        name = name.replace('.', '\\.').replace('*', '.*').replace('?', '.')
    name_pat = re.compile(name, re.IGNORECASE)
    for x in all_tests:
        if name_pat.search(x):
            #print('matched test %s' % x)
            matches.append(x)
        else:
            pass #print('%s doesnt match %s' % (x, name_pat.pattern))
    if not matches:
        print('Cannot find test matching /%s/' % name_pat.pattern)
        sys.exit(1)
    return matches

def say_twice(out1, out2, msg):
    out1.write(msg)
    out2.write(msg)
    out1.flush()
    out2.flush()

def write_std(test_id, txt, which, result):
    if which == 'err' and not txt:
        return
    with open('%s.std%s.%s' % (test_id, which, result), 'w') as f:
         if txt:
             f.write(txt)

def cleanup(data_folder, test_id):
    for item in os.listdir(data_folder):
        if item != 'testing' and (('.std' not in item) or item.startswith('%s.std' % test_id)):
            os.remove(os.path.join(data_folder, item))

def test_one(dist, tests):
    print('\n---- %s %s' % (dist, '-'*(72 - len(dist))))
    folder = unzip(dist)
    if not folder:
        return
    os.chdir(folder)
    old_stdout = sys.stdout
    old_stderr = sys.stderr
    fail_count = 0
    pass_count = 0
    try:
        with open('testdist-results.txt', 'w') as f:

            data_folder = os.path.join(folder, 'testdist-data')
            # Make sure data folder is empty when we start, so no old
            # results confuse us.
            if not os.path.isdir(data_folder):
                os.makedirs(data_folder)
            os.chdir(data_folder)
            if not os.path.exists('testing'):
                os.symlink(my_folder, 'testing')

            sys.stdout = f
            sys.stderr = f
            for test in tests:
                test_id = os.path.split(test)[1][:-5]
                cleanup(data_folder, test_id)
                cmd = 'python %s/check_test.py --prefix %s/code/build/ --test %s' % (my_folder, folder, test)
                #old_stdout.write(cmd + '\n')
                test_name = test[len(my_folder) + 1:]
                say_twice(f, old_stdout, '%s: ' % test_name)
                start_time = time.time()
                child = subprocess.Popen(shlex.split(cmd), stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
                stdout, stderr = child.communicate()
                end_time = time.time()
                result = child.returncode
                failed = result or 'Test passed' not in stdout
                elapsed = end_time - start_time
                result_txt = 'passed'
                if failed:
                    result_txt = 'failed'
                write_std(test_id, stdout, 'out', result_txt)
                write_std(test_id, stderr, 'err', result_txt)
                if failed:
                    fail_count += 1
                    say_twice(f, old_stdout, 'FAILED')
                else:
                    pass_count += 1
                    say_twice(f, old_stdout, 'passed')
                if '/speed/' in test:
                    say_twice(f, old_stdout, ' (%f secs)' % elapsed)
                say_twice(f, old_stdout, '\n')
            say_twice(f, old_stdout, '\nOverall, %d tests passed and %d tests failed.\n' % (pass_count, fail_count))
            if fail_count:
                old_stdout.write('Check out *.std*.failed in %s for details.\n' % data_folder)
    finally:
        sys.stdout = old_stdout
        sys.stderr = old_stderr
        os.chdir(home_folder)

def test_dists(tarballs, tests=None):
    all_tests = find_all_tests()
    if tests:
        matches = []
        for pattern in tests:
            these_matches = find_matching_tests(pattern, all_tests)
            for m in these_matches:
                if m not in matches:
                    matches.append(m)
        tests = matches
    else:
        tests = all_tests
    for dist in tarballs:
        if dist not in tarballs:
            print('Cannot find dist %s.' % dist)
            sys.exit(1)
        test_one(dist, tests)    

if __name__ == '__main__':
    args = sys.argv[1:]
    if len(args) == 1 and help_pat.match(args[0]):
        print('''
testdist [dist] [test1.json [test2.json ...]]

  dist is the name of a zip in ~/. No extension or path allowed.
    If no dist is specified, all dist tarballs are tested.
    
  tests are .json files located anywhere beneath %s.
    No extension or path allowed. If none specified, all are tested.
    
  Results for each zip are stored in the exploded zip's folder
  off of ~/ (e.g., ~/distX/testdist-results.txt)
''' %  my_folder)
        sys.exit(0)
    all_tarballs = find_all_zips()
    if args and (args[0] in all_tarballs):
        tarballs = [args[0]]
        tests = args[1:]
    else:
        tests = args
        tarballs = all_tarballs
    test_dists(tarballs, tests)
